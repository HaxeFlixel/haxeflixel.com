// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, Task, TaskGroup, ambi, domain, events,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ambi = require('ambi');

  events = typeof window !== "undefined" && window !== null ? require('events-browser') : require('events');

  domain = typeof window !== "undefined" && window !== null ? require('domain-browser') : require('domain');

  EventEmitter = events.EventEmitter;

  Task = (function(_super) {
    __extends(Task, _super);

    Task.prototype.type = 'task';

    Task.prototype.result = null;

    Task.prototype.running = false;

    Task.prototype.completed = false;

    Task.prototype.parent = null;

    Task.prototype.taskDomain = null;

    Task.prototype.name = null;

    Task.prototype.method = null;

    Task.prototype.args = null;

    function Task() {
      var args, method, name;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      Task.__super__.constructor.apply(this, arguments);
      name = method = null;
      if (args.length) {
        if (args.length === 2) {
          name = args[0], method = args[1];
        } else if (args.length === 1) {
          method = args[0];
        }
      }
      this.setConfig({
        name: name,
        method: method
      });
      this;
    }

    Task.prototype.setConfig = function(opts) {
      var key, value;
      if (opts == null) {
        opts = {};
      }
      for (key in opts) {
        if (!__hasProp.call(opts, key)) continue;
        value = opts[key];
        this[key] = value;
      }
      return this;
    };

    Task.prototype.reset = function() {
      this.completed = false;
      this.running = false;
      this.result = null;
      return this;
    };

    Task.prototype.uncaughtExceptionCallback = function() {
      var args, err;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      err = args[0];
      if (!this.completed) {
        this.complete(args);
      }
      this.emit('error', err);
      return this;
    };

    Task.prototype.completionCallback = function() {
      var args, err;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (!this.completed) {
        this.complete(args);
        this.emit.apply(this, ['complete'].concat(__slice.call(this.result)));
      } else {
        err = new Error("A task's completion callback has fired when the task was already in a completed state, this is unexpected");
        this.emit('error', err);
      }
      return this;
    };

    Task.prototype.destroy = function() {
      this.removeAllListeners();
      return this;
    };

    Task.prototype.complete = function(result) {
      this.completed = true;
      this.running = false;
      this.result = result;
      return this;
    };

    Task.prototype.fire = function() {
      var args,
        _this = this;
      args = (this.args || []).concat([this.completionCallback.bind(this)]);
      if (this.taskDomain == null) {
        this.taskDomain = domain.create();
        this.taskDomain.on('error', this.uncaughtExceptionCallback.bind(this));
      }
      this.taskDomain.run(function() {
        var err;
        try {
          return ambi.apply(null, [_this.method.bind(_this)].concat(__slice.call(args)));
        } catch (_error) {
          err = _error;
          return _this.uncaughtExceptionCallback(err);
        }
      });
      return this;
    };

    Task.prototype.run = function() {
      var err;
      if (this.completed) {
        err = new Error("A task was about to run but it has already completed, this is unexpected");
        this.emit('error', err);
      } else {
        this.reset();
        this.running = true;
        this.emit('run');
        process.nextTick(this.fire.bind(this));
      }
      return this;
    };

    return Task;

  })(EventEmitter);

  TaskGroup = (function(_super) {
    __extends(TaskGroup, _super);

    TaskGroup.prototype.type = 'taskgroup';

    TaskGroup.prototype.running = 0;

    TaskGroup.prototype.remaining = null;

    TaskGroup.prototype.err = null;

    TaskGroup.prototype.results = null;

    TaskGroup.prototype.parent = null;

    TaskGroup.prototype.paused = true;

    TaskGroup.prototype.bubbleEvents = null;

    TaskGroup.prototype.name = null;

    TaskGroup.prototype.method = null;

    TaskGroup.prototype.concurrency = 1;

    TaskGroup.prototype.pauseOnError = true;

    function TaskGroup() {
      var args, me, method, name;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.addGroup = __bind(this.addGroup, this);
      this.addTask = __bind(this.addTask, this);
      me = this;
      TaskGroup.__super__.constructor.apply(this, arguments);
      if (this.results == null) {
        this.results = [];
      }
      if (this.remaining == null) {
        this.remaining = [];
      }
      if (this.bubbleEvents == null) {
        this.bubbleEvents = ['complete', 'run', 'error'];
      }
      name = method = null;
      if (args.length) {
        if (args.length === 2) {
          name = args[0], method = args[1];
        } else if (args.length === 1) {
          method = args[0];
        }
      }
      this.setConfig({
        name: name,
        method: method
      });
      process.nextTick(this.fire.bind(this));
      this.on('item.complete', this.itemCompletionCallback.bind(this));
      this.on('item.error', function(item, err) {
        me.stop();
        return me.emit('error', err);
      });
      this;
    }

    TaskGroup.prototype.setConfig = function(opts) {
      var key, value;
      if (opts == null) {
        opts = {};
      }
      for (key in opts) {
        if (!__hasProp.call(opts, key)) continue;
        value = opts[key];
        this[key] = value;
      }
      return this;
    };

    TaskGroup.prototype.fire = function() {
      var args;
      if (this.method) {
        args = [this.addGroup, this.addTask];
        this.addTask(this.method.bind(this)).setConfig({
          args: args,
          includeInResults: false
        });
        if (!this.parent) {
          this.run();
        }
      }
      return this;
    };

    TaskGroup.prototype.itemCompletionCallback = function() {
      var args, item;
      item = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (item.includeInResults !== false) {
        this.results.push(args);
      }
      if (args[0]) {
        this.err = args[0];
      }
      if (this.running > 0) {
        --this.running;
      }
      if (this.paused) {
        return;
      }
      if (!this.complete()) {
        this.nextItems();
      }
      return this;
    };

    TaskGroup.prototype.getTotals = function() {
      var completed, remaining, running, total;
      running = this.running;
      remaining = this.remaining.length;
      completed = this.results.length;
      total = running + remaining + completed;
      return {
        running: running,
        remaining: remaining,
        completed: completed,
        total: total
      };
    };

    TaskGroup.prototype.addItem = function(item) {
      var me;
      me = this;
      this.bubbleEvents.forEach(function(bubbleEvent) {
        return item.on(bubbleEvent, function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return me.emit.apply(me, ["item." + bubbleEvent, item].concat(__slice.call(args)));
        });
      });
      this.emit('item.add', item);
      this.remaining.push(item);
      if (!this.paused) {
        this.nextItems();
      }
      return item;
    };

    TaskGroup.prototype.createTask = function() {
      var args, task;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      task = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Task, args, function(){});
      return task;
    };

    TaskGroup.prototype.addTask = function() {
      var args, me, task;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      me = this;
      task = this.createTask.apply(this, args).setConfig({
        parent: this
      });
      this.bubbleEvents.forEach(function(bubbleEvent) {
        return task.on(bubbleEvent, function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return me.emit.apply(me, ["task." + bubbleEvent, task].concat(__slice.call(args)));
        });
      });
      this.emit('task.add', task);
      return this.addItem(task);
    };

    TaskGroup.prototype.createGroup = function() {
      var args, group;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      group = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(TaskGroup, args, function(){});
      return group;
    };

    TaskGroup.prototype.addGroup = function() {
      var args, group, me;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      me = this;
      group = this.createGroup.apply(this, args).setConfig({
        concurrency: this.concurrency,
        parent: this
      });
      this.bubbleEvents.forEach(function(bubbleEvent) {
        return group.on(bubbleEvent, function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return me.emit.apply(me, ["group." + bubbleEvent, group].concat(__slice.call(args)));
        });
      });
      this.emit('group.add', group);
      return this.addItem(group);
    };

    TaskGroup.prototype.hasItems = function() {
      return this.remaining.length !== 0;
    };

    TaskGroup.prototype.isReady = function() {
      return !this.concurrency || this.running < this.concurrency;
    };

    TaskGroup.prototype.nextItems = function() {
      var item, items, result;
      items = [];
      while (true) {
        item = this.nextItem();
        if (item) {
          items.push(item);
        } else {
          break;
        }
      }
      result = items.length ? items : false;
      return result;
    };

    TaskGroup.prototype.nextItem = function() {
      var nextItem;
      if (this.hasItems()) {
        if (this.isReady()) {
          nextItem = this.remaining.shift();
          ++this.running;
          nextItem.run();
          return nextItem;
        }
      }
      return false;
    };

    TaskGroup.prototype.complete = function() {
      var completed, empty, pause;
      pause = this.pauseOnError && this.err;
      empty = this.hasItems() === false && this.running === 0;
      completed = pause || empty;
      if (completed) {
        if (pause) {
          this.pause();
        }
        this.emit('complete', this.err, this.results);
        this.err = null;
        this.results = [];
      }
      return completed;
    };

    TaskGroup.prototype.clear = function() {
      var item, _i, _len, _ref;
      _ref = this.remaining.splice(0);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        item.destroy();
      }
      return this;
    };

    TaskGroup.prototype.destroy = function() {
      this.stop();
      this.removeAllListeners();
      return this;
    };

    TaskGroup.prototype.stop = function() {
      this.pause();
      this.clear();
      return this;
    };

    TaskGroup.prototype.exit = function(err) {
      if (err) {
        this.err = err;
      }
      this.stop();
      this.running = 0;
      this.complete();
      return this;
    };

    TaskGroup.prototype.pause = function() {
      this.paused = true;
      return this;
    };

    TaskGroup.prototype.run = function() {
      var args, me;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      me = this;
      this.paused = false;
      this.emit('run');
      process.nextTick(function() {
        if (!me.complete()) {
          return me.nextItems();
        }
      });
      return this;
    };

    return TaskGroup;

  })(EventEmitter);

  module.exports = {
    Task: Task,
    TaskGroup: TaskGroup
  };

}).call(this);
